<!DOCTYPE html>
<html>
  <head>
    <title>(4) C++11 / Boost Library Workshop - Tuesday 2</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!-- when changing the stylesheet file please see also remark below -->
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: refersto
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.refersto.right[
See also {{see_also}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++11 BLWS]: 00_topics.html#agenda

# [C++11 BLWS] (Tuesday 2)
.center[A Mix of Useful Things]

---------------------------------------------------------------------------

1. [Formatting					](#formatting)
1. [Boost: I/O-State Saver			](#boost_i_o_state_saver)
1. [Boost: format				](#boost_format)
1. [Boost: File System				](#boost_file_system)
1. [C++11: Chrono				](#cpp11_chrono)
1. [Boost: Date & Time				](#boost_date_time)
1. [C++11: Random				](#cpp11_random)

---------------------------------------------------------------------------

Short breaks will be inserted as convenient.

---
template: refersto
see_also: Josuttis: 15.7
name: formatting
header: ## Formatting

Compared to C-style `printf`-format strings C++ output formatting has changed
the concept dramatically. One of the main reasons probably was to get more
type safety as C could provide.

The big obstacle with the C++ design is its stateful stream formatting:._[]

* E.g. switching to a hexadecimal output format will be persistant …

* … until switched back to decimal – which introduces the problem:

* What if the prior output format wasn't decimal but octal?

.W[
Any local change of persistant stream formatting settings should be undone
afterwards, otherwise unwanted effects lurk around the corner, especially if
the program logic has branches which are rarely taken and therefore not
thoroughly tested.
]

.F[:
Sometimes the fact that Bjarne Stroustrup had chosen to overload the shift
operators for I/O is also heavily criticised, though nowadays few C++ developers
seem to share this view and some even call `operator<<` the *output operation*
…
]

---
template: refersto
see_also: Josuttis 15.12.2
name: sharing_streambuf
header: ### Sharing Stream Buffers

One lesser known option to avoid resetting the format flags to the original
state is to work with several separate stream that share the same buffer:._[]
```
#include <iostream>
#include <iomanip>
int main() {
    std::ostream octout{std::cout.rdbuf()}; octout << std::oct;
    std::ostream decout{std::cout.rdbuf()}; decout << std::dec;
    std::ostream hexout{std::cout.rdbuf()}; hexout << std::hex;
    std::cout << "char oct dex hex\n"; 
    for (char c{'a'}; c <= 'z'; ++c) {
        const int v{c};
        std::cout << "'" << c << "'  ";
        octout << std::setw(3) << v << ' ';
        decout << std::setw(3) << v << ' ';
        hexout << std::setw(3) << v << '\n';
   }
}
```

.F[:
This example demonstrates the principles but is not that clearly showing the
advantages, mainly because lack of space (to make it fit on a single page). To
get a better idea how it could improve a larger program's structure, imagine the
output operations were in separate functions, called intermingled with other
output operations that expect a certain formatting state.
]

---
template: refersto
see_also: Josuttis 15.7.1
name: iostream_fmtflags
header: ### Saving and Restoring Format Flags

The direct way to restore the original state is to use the member functions to
get and save the current flags, modify formatting as needed, print the value,
and finally restore the saved flags:._[]
```
// on ostream 'os' print 'v' in hexadecimal, using uppercase for
// letters A..F, prefixed with 0x (lower case 'x'), with minimum
// field width as set before calling to this function
void print_hex(std::ostream &os, unsigned long long val) {
    const auto usewidth = (os.width()) < 2 ? : os.width() - 2;
    const auto oldflags = os.flags(std::ios::hex
                                 | std::ios::uppercase
                                 | std::ios::right);
    const auto oldfill = os.fill('0');
    os << std::setw(0) << "0x" << std::setw(usewidth) << val;
    os.setf(oldflags);
    os.fill(oldfill);
}
```

.N[
Note that setting the minimum field width is **not persistent** and will always
apply to the next output, then reset to zero.
]

---
template: refersto
see_also: BoostLibs: io/doc/ios_state
name: boost_i_o_state_saver
header: ## Boost: I/O-State Saver

[Boost.Scope_exit]: http://www.boost.org/doc/libs/release/libs/scope_exit/doc/html/index.html
[Boost.IO_State_Savers]: http://www.boost.org/doc/libs/release/libs/io/doc/ios_state.html

The idea behind [Boost.IO_State_Savers] is to restore flags in a destructor at
scope exit:._[]
```
void print_hex(std::ostream &os, unsigned long long val) {
    const auto usewidth = (os.width()) < 2 ? : os.width() - 2;
    boost::io::ios_flags_saver flags(os);
    boost::io::ios_fill_saver fill(os);
    os << std::setw(0) << "0x"
       << std::hex << std::uppercase << std::right
       << std::setfill('0') << std::setw(usewidth) << val;
}
```
.N[
The advantages of this approach become even more visible if control flow is not
as linear as above. Especially if exceptions might occur, no `try`-`catch`-logic
must be added.
]

Using manipulators instead of member function to change the formatting state is
not essential here but makes the code even more compact.

.F[:
[Boost.Scope_exit] generalizes the idea to arrange beforehand that an arbitrary
block of code gets executed on scope exit via the destructor of a block-local
object.
]


---
template: refersto
see_also: Schäling: 5.6
name: boost_format
header: ## Boost: format

[Boost.Format]: http://www.boost.org/doc/libs/release/libs/format/doc/format.html

[Boost.Format] is the return of C's `printf`-style output formatting to C++._[]

* The core format string language is much similar to C.

* Beyond this there are many extensions, e.g.

  * the order of values to format must not necessarily be the same as the order
    of place holders in the format string.

  * Extensions for user specified types are possible …

  * … but even without, any type that has `operator<<` defined will work.

.N[
Type safety is guaranteed at run time, i.e. an exception will be thrown if a
value to format is not compatible with the placeholder.
]


---
template: refersto
see_also: Schäling: 9
name: boost_file_system
header: ## Boost: File System

[Boost.Filesystem v2]: http://www.boost.org/doc/libs/1_49_0/libs/filesystem/v2/doc/index.htm
[Boost.Filesystem V3]: http://www.boost.org/doc/libs/1_49_0/libs/filesystem/v3/doc/index.htm
[TR2 Path]: http://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1#Technical_Report_2
[Microsoft Visual Studio 2013]: http://msdn.microsoft.com/en-us/library/hh874694.aspx

Even with C++11 there is no portable way to access the file system to

* search through directories and sub-directories,

* determine and change file properties,

* delete, rename, link, or copy files.

.N[
Boost had tried to tackle this since a long time – with more or less success –
and is currently in its 3rd major release [Boost.Filesystem V3].
]

This file system library may also – via the [TR2 Path] – become available with
recent Standard C++ versions and is part of [Microsoft Visual Studio 2013].

.F[:
At the time of writing the final state of affairs is not quite clear. A major
obstacle through all the years seems to have been uniting the classic and also
modern 8-bit-char API of Unix/Linux (using UTF-8 now, which the clients – by and
large – can handle "content-agnostic") with the 16-bit-char API of MS-Windows in
a portable way …
]


---
template: refersto
see_also: Josuttis: 5.7
name: cpp11_chrono
header: ## C++11: Chrono

With C++11 a library component for managing date and time was introduced
(beyond what was available for long because of C compatibility).

* As many similar libraries it makes a clear distinction between

  * durations and

  * time points.

The feature that makes this library shine is its flexibility with respect to
the usual trade-off between resolution, range, and space requirements of the
underlying type (to store a duration or time point).

.I[
The chapter on the C++11 *Chrono Library Part* from Nicolay Josuttis Books,
referenced above, has also been made available online here:

http://www.informit.com/articles/article.aspx?p=1881386&seqNum=2
]


---
template: refersto
see_also: Josuttis: 5.7.2
name: chrono_duration
header: ### `std::chrono` – Durations

Though the duration type is fully configurable through a template._[], most
programs will probably choose from one of the predfined types that satisfies
their needs for resolution:

* `std::chrono::nanoseconds` at least 64 bit signed
* `std::chrono::microseconds` at least 55 bit signed
* `std::chrono::milliseconds` at least 45 bit signed
* `std::chrono::seconds` at least 35 bit signed
* `std::chrono::minutes` at least 29 bit signed
* `std::chrono::hours` at least 23 bit signed

.N[
Duration type conversions to a *finer grained* type will allways happen
automatically, while conversions to *coarser grained* type require an
`std::chrono::duration_cast`.
]

A 64-bit type the minimum requirement for nanosecond resolution – with the
**minimum requirement** for the other types adapted accordingly – the minimum
range of a duration covers ±500 years.

.F[:
E.g. a duration type could well count in 5/17 microseconds if that matches the
resolution of a hardware timer exactly and allows for precise calculations
without any rounding errors or occasional jitter.
]

---
template: refersto
see_also: Josuttis: 5.7.3
name: chrono_clock
header: ### `std::chrono` – Clocks

A duration (type) combined with an *epoche*._[] is said to be a *clock* and
represents a time point.

Which kind of clocks are supported is basically implementation defined with the
following minimum requirements:

* `std::chrono::system_clock` – represents the usual "wall-clock" or "calendar
  date & time" of a computer system;

* `std::high_resolution_clock` – the clock with the best resolution available
  (but with a more or less frequent wrap-around);

* `std::chrono::steady_clock` – probably not tied to a specific calendar date
  and with the special guarantee that it will only advance. 

.N[
Only the last allows to realiably determine a real time span as difference of
two time points returned from its static member function `now()`.
]

.F[:
Per definition the epoche of a clock is the time point represented by the
duration zero. From its epoche a clock will reach into the past and into the
future, usually symmetrically if an ordinary signed integral or floating point
type is used.
]

---
template: plain
name: chrono_operatios
header: ### `std::chrono` – Operations

Operators are overloaded to support mixed durations and time points:

|Operand Type| Operation       |Operand Type  |Result Type    |
|:-----------|:---------------:|:-------------|:--------------|
| duration   | plus or minus   | duration     | duration      |
| time point | plus or minus   | duration     | time point    |
| time point | minus           | time point   | duration      |
| duration   | multiplied with | plain number | duration      |
| duration   | divided by      | plain number | duration      |
| duration   | modulo          | plain number | duration      |
| duration   | divided by      | duration     | plain number  |
| duration   | modulo          | duration     | duration      |

Combinations not listed in the table above result in compile time errors.

For operands with standard types._[] of different resolution the result will use
the appropriate type with the finer grained resolution.

.F[:
When non-standard types are combined the required result type will be calculated
accordingly. E.g. to store the sum of a duration counting in 10/21 seconds and
another one counting in 14/15 seconds, a result type counting in 1/105 seconds
will be used.
]

---
template: refersto
see_also: Schäling: 10
name: boost_date_time
header: ## Boost: Date & Time

[Boost.Date_time]: http://www.boost.org/doc/libs/release/doc/html/date_time.html
[Boost.Chrono]: http://www.boost.org/doc/libs/release/doc/html/chrono.html

[Boost.Date_time] has little in common with [C++11 Chrono](#cpp11_chrono),
except for maintaining a similar semantic difference between durations and time
points.

.N[
While legacy code using that library will still be around for some years, on the
long run it can be expected that the importance and user base of this library
may decrease and code be updated to use `std::chrono`.._[]
]

.F[:
Note that with [Boost.Chrono] the Chrono Library as standardized with C++11 is
now available on the Boost platform too.
]

---
template: refersto
see_also: Josuttis: 17.1
name: cpp11_random
header: ## C++11: Random

Compared to C style pseudo random number generation with `std::rand`, C++11 has
adopted a facility for generating random numbers with given distributions, but
at a price:

The code to role a simple dice isn't any more as easy._[] as
```
int throw_dice() { return 1 + std::rand() % 6; }
```

but requires at least something along the following lines:
```
int throw_dice() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(1, 6);
    return dis(gen);
}
```

.F[:
… and wrong or at least flawed for the following reasons: (1) Some C
implementations start to repeat the "random" sequence as early as after 65534
repetitions and (2) if the range of pseudo-random numbers (starting with zero)
is not evenly divisible by six the chosen way to map the numbers to 1..6 will
slightly favour the lower values.
]

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>
