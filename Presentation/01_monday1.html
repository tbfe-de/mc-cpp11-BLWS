<!DOCTYPE html>
<html>
  <head>
    <title>(1) C++11 / Boost Library Workshop - Monday (1)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!-- when changing the stylesheet file please see also remark below -->
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: refersto
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies aproximately 2/3 of the page width. So only add
  little information, preferrably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.refersto.right[
See also {{see_also}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
layout: false
template: blank

  [C++11 BLWS]: 00_topics.html#agenda

# [C++11 BLWS] (Monday 1)
.center[Some Fundamentals]

---------------------------------------------------------------------------
1. [C++11: Syntax Cleanups		](#cpp11_syntax_cleanups)
1. [C++11: `auto`-typed Variables	](#cpp11_auto_typed_variables)
1. [C++11: Builtin `decltype`		](#cpp11_builtin_decltype)
1. [Boost: Type-of			](#boost_type_of)
1. [C++11: Uniform Initialization	](#cpp11_uniform_initialization)
1. [C++11: Range-Based Loops		](#cpp11_range_based_for_loops)
1. [Boost: For-each			](#boost_foreach)
1. [C++11: Move Semantics		](#cpp11_move_semantics)
1. [C++11: Rvalue References		](#cpp11_rvalue_references)
1. [Boost: Noncopyable			](#boost_noncopyable)
1. [C++11: Static Assertions		](#cpp11_static_assertions)
1. [Boost: Static Assert		](#boost_static_assert)
1. [C++11: `constexpr` Functions	](#cpp11_constexpr_functions)
1. [C++11: Template Typedefs		](#template_typedefs)
1. [Exercise (optional)			](#exercise_monday1)
---------------------------------------------------------------------------

Short breaks will be inserted as convenient.

---
template: refersto
see_also: Josuttis: 3.1.1
name: cpp11_syntax_cleanups
header: ## C++11 – Syntax Cleanups

Maybe the most important syntax cleanup – for some, while others may consider
it minor – allows to write adjacent *less-than* signs as closing angle
brackets for template argument lists:._[]
```
map<string, vector<int>> wordposlist;
```

.F[:
It should be noted that this change breaks previously valid code that used the
right-shift operator in an expression to specifiy a template value argument.
Therefore `g++` changes its behaviour depending on the option `-std=c++11`
(or `-std=c++0x` for less recent versions). Old code with shift operators as
part of a template value argument must put the expression in parentheses.
]

While some compilers (like Visual Studio) since long handled the above according
to the C++11 rules, others (like GCC) required
```
map<string, vector<int> > wordposlist;
```

and some extra-careful developers even wrote:
```
map<string, vector<int>/**/> wordposlist;
```

---
template: refersto
see_also: Josuttis: 3.1.2
name: cpp11_auto_typed_variables
header: ## C++11: `auto`-typed Variables

The old C keyword `auto` has changed its meaning with C++11:

* It now specifies that the type for some variable is deduced from its
  initializing expression.

* Note that type modifiers may be added but also might be stripped from the
  initializing expression.._[]

```
auto x = 3;         // x has type int
auto y = 0uL;       // y has type unsigned long
auto p1 = &x;       // p1 has type int*
auto *p2 = &x;      // p2 has type int* too (!)
const auto cx = 42; // cx has type const int BUT ...
auto ncx = cx;      // ... ncx has type int (NOT const int)
int &ri = x;        // ri has type int& BUT ...
auto nri = x;       // ... nri has type int (NOT int&)
```

.F[:
The rules are very close to the rules applied when for template functions types
are deduced from actual arguments.
]

---
template: refersto
see_also: Josuttis: 3.1.11
name: cpp11_builtin_decltype
header: ## C++11: Builtin `decltype`

The compiler-builtin `decltype` is now available to

* determine the type of a variable or

* an expression (which will not be evaluated!)

```
// continuing the example from the previous page
… decltype(x) …              // represents type int
… decltype(ri) …             // represents type int&
… decltype(x+y) …            // represents type unsigned long
… decltype(std::sqrt(-1)) …  // represents type double
```

.I[
One main use for `decltype` is in templates to determine the result of an
operation with operands of a dependant type.._[]
]

.F[:
If the type is necessary for the result of a function the new suffix return
type syntax of C++11 comes in handy.
]

---
template: refersto
see_also: BoostBook: typeof
name: boost_type_of
header: ## Boost: Type-of

[Boost.Typeof]: http://www.boost.org/doc/libs/release/doc/html/typeof/refe.html

Also [Boost.Typeof] provides extensions similar to `auto` and `decltype`.

As these had to be implemented as library functionality._[] they

* are much more limited and clumsy to use,

* result in less readable code.

.F[:
Of course, where C++98 compilers provided useful non-standard extensions the
Boost functions made use thereof.
]

.N[
Therefore it can be expected that such parts of Boost become obsolete as soon
as C++11 is implemented by all compilers relevant for productive use with a
software project's code base.
]

---
template: refersto
see_also: Josuttis: 3.1.3
name: cpp11_uniform_initialization
header: ## C++11: Uniform Initialization

C++ traditionally had many forms of initialization, some of which were limited
to certain contexts:
```
int x = 0;                     // traditional style
const std::string greet("hi"); // constructor style
struct s {
    int a;
    char z;
} v = { 42, '!' };             // aggregate initialization
std::string empty();           // INVALID (as initialization)
unsigned u = unsigned();       // not common but valid (in C++)
```

Since C++11 curly braces may be used in any initialization context:._[]
```
int x{0};                      // explicit zero initialization
const std::string greet{"hi"}; // initialization by constructor
string empty{};                // valid for default constructor
unsigned u{};                  // implicit zero initialization
```

.F[:
Compared to classic initialization some rules have slightly changed:
E.g. if the value of the initializing expression cannot be represented in
the initialized variable, this is a compile time error.
]

---
template: plain
name: cpp11_initializer_lists
header: ### C++11: Initializer Lists

Initializer lists are sequences of comma-sparated values enclosed in curly
braces.

* They are valid wherever a function accepts an argument of type
  `std::initializer_list`.

* This includes many constructors for standard containers:._[]

.W[
A few usage forms introduced ambiguities for which C++11 defined disambiguating
rules – sometimes little intuitive ones.
]
```
vector<short> primes({ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 });
const map<string, string> words = {
    { "zero", "null" }, { "one", "eins" }, { "two", "zwei" },
    …
};
vector<int> x{3};  // A vector initialized with a "list" just
                   // holding a single 3?
                   // Or rather a vector sized to 3 elements
                   // that shall be default-initialized?
```

---
template: refersto
see_also: BoostLibs: utility/value_init
name: boost_value_initialized
header: ### Boost: Value Initialized

[Boost.Value_initialized]: http://www.boost.org/doc/libs/release/libs/utility/value_init.htm

Using the correct initialization syntax can pose a problem._[] at times:
```
template<typename T> void foo() {
    T local = … // ???
    …
}
```

* A plain `T local;` would default initialize classes but leaves basic types
  uninitialized.

* Classic style `T local = 0`; would only zero-initialize basic types.._[]

[Boost.Value_initialized] provides a utility template, causing either zero or
default initialization, depending on the type of `T`:
```
value_initialized<T> local; // uniform use of the Boost solution
T local = T();       // a (somewhat lesser known) C++98 solution
T local{};           // C++11 uniform initialization as solution
```

.F[:
Actually the state of affairs is a bit more complicated: The above would also
work if `T` were a class with a (non-`explicit`) constructor taking an argument
type to which `0` can be converted. Besides all arithmetic types this include
`bool` (`0` converted to `false`) and any pointer type (`0` converted to
`nullptr`).
]

---
template: refersto
see_also: BoostLibs: assign/doc/index
name: boost_container_initialization
header: ### Boost: Container Initialization

[Boost.Assign]: http://www.boost.org/doc/libs/release/libs/assign/doc/index.html

[Boost.Assign] provides some operator overloading to allow a more readable
initialization syntax for sequential and associative containers.

Overloaded `operator,` and `operator+=` help with sequential containers:
```
vector<int> primes;
primes += 2, 3, 5, 7, 11, 13, 17, 19, 23, 29;
```

For associative containers there is a somewhat tricky overload of `operaror()`
(function call):
```
map<string, string> words;
words(("one")("eins"))
     (("two")("zwei"))
     …
     (("nine")("neun"))
     ;
```

.N[
Compared to [C++11 initializer lists](#cpp11_initializer_lists) the above not
only looks clumsy but also has the draw-back that no `const`-qualifiers are
possible.
]

---
template: refersto
see_also: Josuttis: 3.1.4
name: cpp11_range_based_for_loops
header: ## C++11: Range-Based `for` Loops

C++11 supports a new and uniform syntax to loop over all elements in a
collection:
```
vector<int> primes;
…
for (auto v : primes)
    … // access element through v
```
Nothing changes if `primes` were any other sequential or associative
container._[], a builtin array, or even an `std::initializer_list`:
```
for (auto v : { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 })
    … // access element through v
```

.F[:
For maps the placeholder variable will be an `std::pair` to access the key via
`v.first` and the associated value via `v.second`.
]

.N[
It is only little effort – if there is no standard iterator interface anyway –
to make user-supplied containers iteratable with range based loops.
]

---
template: refersto
see_also: BoostBook: foreach
name: boost_foreach
header: ## Boost: Foreach

[Boost.Foreach]: http://www.boost.org/doc/libs/release/doc/html/foreach.html

Like some other third party libraries._[] [Boost.Foreach] tries to outwit C++98
with a macro – called `BOOST_FOREACH` in this case – that mimics what has become
a builtin in C++11:

```
vector<int> primes;
…
BOOST_FOREACH(int v, primes)
    … // access elements via v
```

.F[:
An assembler code analysis of `BOOST_FOREACH` is still pending on behalf of the
author of this text. But it was done for the Qt version once, and in that case
the result was a convincing argument **against** using such trickery … at least
when code efficiency is the primary target: For builtin types Qt's for-each
produced as much as ten times the amount of code compared to a classic `for`
loop!
]

---
template: refersto
see_also: Josuttis: 3.1.5
name: cpp11_move_semantics
header: ## C++11: Move Semantics

[RVO and NRVO]: http://stupefydeveloper.blogspot.de/2008/10/c-rvo-and-nrvo.html
[Perfect Forwarding]: http://thbecker.net/articles/rvalue_references/section_07.html

Move semantics provide the solution to two problems that could not (always)
be avoided in C++98:

* Efficient use of *value types as function return values*, e.g. if they
  represent large containers.

* Implementing types that are *movable* but not *copyable*.._[]

.F[:
With C++98 there is no real solution to the problem to differentiate between
moveable and copyable types. Even if `operator=` stays undefined and overloaded
global functions `assign` and `move` were used consequently, especially in
type-generic code of template implementations something in the vein of
[Perfect Forwarding] could not be achieved, at least not with as little code
as can now.
]

.I[
Even before C++11 in many practical cases the leeway given to a compiler to
apply [RVO and NRVO] could achieve much to **return large data structures by
value efficiently**.
]

But as there is no guarantee in this respect, the usual recommendation for C++98
was to hand-out large containers via reference arguments, not by return value –
and this recommendation should possibly be followed even in C++11.

---
template: refersto
see_also: Josuttis: 3.1.5
name: cpp11_rvalue_references
header: ## C++11: Rvalue References

[Rvalue References]: http://thbecker.net/articles/rvalue_references/section_01.html

Move semantics heavily build on [Rvalue References] defined with a double
ampersand:
```
void foo(const T &classic_reference) { … } //first
void foo(T &&rvalue_reference) { … } //second
```

With the above two overloads C++11 would bind

* the first `foo` to arguments that are plain variables (including `const`
  qualified variables),

* the second `foo` to arguments that are temporaries which will be destroyed
  soon after use.._[]

```
T a; const T b; extern T bar();
foo(a);	    // calls first
foo(b);	    // calls first
foo(bar()); // calls second
foo(a+a);   // calls second -- provided T supports operator+
```

.F[:
Such as function calls, but also including constants and expressions (with some
reasonable exemptions).
]

---
template: plain
header: ## Copyable and Movable Types

Instances of the following class will be both, copyable and movable:
```
class MyClass {
    …
public:
    MyClass(const MyClass &); // classic copy constructor and ...
    const MyClass& operator=(const MyClass &); // copy assignment
    …
    MyClass(MyClass &&);        // C++11 move constructor and ...
    const MyClass& operator=(MyClass &&);      // move assignment
}
```

By supplying both of move and copy support, or only the one or the other, or
none at all, instances of `MyClass` can easily be made

* **Copyable** and **Movable**,
* **Copyable** but not Moveable,
* not Copyable but **Movable**, or
* neither Copyable nor Moveable.

---
template: plain
name: cpp11_defaulted_deleted
header: ### C++11: `default`-ed and `delete`-d Operations

C++11 furthermore provides a particular syntax to request or forbid compiler
generated constructors and assignments, making it easy to write a class that
supports the required behavior:
```
class MyClass {
    …
public:
    MyClass(const MyClass &)                   = delete;
    const MyClass& operator=(const MyClass &)  = delete;
    …
    MyClass(      MyClass &&)                  = default;
    const MyClass& operator=(      MyClass &&) = default;
 };
```

.N[
It is probably easy to spot that instances of the above class will be moveable
but not copyable and what needs to be changed if that should be different.
]

In case the default implementation provided for the above operations is not
appropriate, then of course a specific implementation can be supplied.

---
template: refersto
see_also: BoostBook: core
name: boost_noncopyable
header: ## Boost: Noncopyable

[`boost::noncopyable`]: http://www.boost.org/doc/libs/release/libs/utility/utility.htm#Class_noncopyable

As C++ always generates a copy constructor when none is specified,._[] the usual
technique is to *declare-but-not-implement* the unwanted operation.

.F[:
Note that with C++11 the rules changed in so far as **no default copy-constructor
will be provided if a move-constructor is provided**, and the same holds for copy-
and move-assignment. The reasoning behind that rule is that as soon as a specific
behavior is necessary for one, copy or move, it will probably also be the case for
the other.
]

Via deriving from `boost::noncopyable` the intent can be made more obvious
(and code a bit more compact):
```
class MyClass : boost::noncopyable {
    …
    … // whatever (but no need any more to define
    … // operations that never get implemented)
    …
};
```

---
template: plain
name: cpp11_static_assertions
header: ## C++11: Static Assertions

With C++11 compile time checks can be expressed that will abort a compilation
if they fail. They are possible (and mainly used) inside

* code blocks (mixed with code to execute at runtime) and

* class defintions (typically for templates).

```
template<typename T, size N>
class RingBuffer {
    static_assert(N < 1000, "unreasonable large size");
    …
};
```

.I[
For more complicated tests static assertions may want to move the actual
calculations to a [`constexpr` Function](#cpp11_constexpr_functions).
]

---
template: refersto
see_also: BoostBook: static_assert
name: boost_static_assert
header: ## Boost: Static Assert

Static assertions are also available from Boost via

* `BOOST_STATIC_ASSERT`

but as prior to C++11 such assertions had somehow to "be turned into ordinary
syntax errors" the error messages finally issued tended to be less indicative
of the problem or even slightly misleading.._[]

.F[:
A common technique was to turn the assertion into the definition of an array
with a zero or negative size, which is illegal in C and C++.
]

---
template: refersto
see_also: Josuttis: 3.1.8
name: cpp11_constexpr_functions
header: ## C++11: `constexpr` Functions

If a function is marked with the new `constexpr` keyword it will – given it
adhers to certain limitations – be "compiled inside the compiler" and hence be
callable at compile time.

Besides possible performance improvements for functions called with compile-time
constants as arguments anyway, the result of such functions can be used in any
context that requires a compile-time constant.._[]

.F[:
With the cases of practical importance being array dimensions, template value
arguments, static assertions, or in turn arguments to call other `constexpr`
functions.
]

```
constexpr bool is_pwrof2(unsigned v) {
    return v != 0 && (v == 1 || (!(v & 1) && is_pwrof2(v >> 1)));
}
…
const unsigned N = 4095; // should always be some 2^n - 1
static_assert(!is_pwrof2(N+1), "N is not some 2^n - 1");
```

---
template: plain
name: template_typedefs
header: ### Compile-Time Calculations with Templates

Prior to C++11 compile-time calculations had to be carried out using
meta-programming techniques based on templates:._[]
```
template<unsigned long long v>
struct is_pwrof2 {
    static const bool result = !(v & 1)
                            && is_pwrof2<(v >> 1)>::result;
};
template<> struct is_pwrof2<0uLL> {
    static const bool result = false;
};
template<> struct is_pwrof2<1uLL> {
    static const bool result = true;
};
```

The "call syntax" for such a function._[] – when `N` is another compile-time
constant – will be: `… is_pwrof2<N>::result …`

.F[:
Differently from `constexpr` functions, which will be also available with a
run-time version to be called with non-constant arguments, a function
implemented with meta-programming techniques via a template could of course
not be called in a loop for testing purposes!
]

---
template: plain
name: template_typedefs
header: ### Support for Meta-Programming in Boost

[Boost.MPL]: http://www.boost.org/doc/libs/release/libs/mpl/doc/index.html
[Meta-Programming with Templates]: http://en.wikipedia.org/wiki/Template_metaprogramming

Though `constexpr` functions provide a nice alternative to template-based
techniques when non-trivial calculations have to be carried out, there are
numerous other applications of meta-programming with templates.

In such cases there will most probably be the need

* to *"operate on types"* (single ones or lists thereof)

* as *"input to"* and "output from" a metaprogram.._[]

.F[:
In meta-programming dominant type calculations may be mixed with occasional
value-based calculations. A "meta-programmer" may therefore have to *cross the
compile-time to run-time border-line*. Nevertheless it should be understood
that the MPL does not work with values but with *types* to be *stored* in MPL
containers and *processed* with MPL algorithms.
]

.N[
[Boost.MPL] is a *Library for Meta-Program-Developers* with STL-like
containers and algorithms – besides a lot of other useful things.
]

As [Meta-Programming with Templates] is a large and demanding topic that alone
could fill some days in a course like this, it will not be covered any further,
except on special demand.

---
template: plain
name: template_typedefs
header: ## C++11: Template Typedefs

Despite the name._[] this new C++11 syntax is not limited to templates – instead
it can fully replace the classic `typedef` syntax:

.F[:
The name is a relict from the motivation finally leading to the syntax shown
here, which provided a more general solution than originally was aimed for.
]

.pull-left[
```
// old style typedef-syntax:
typedef unsigned long METER;
typedef void *pointer_type;
typedef const char *(*CV)(int);
```
]

.pull-right[
```
// new style using-syntax:
using METER = unsigned long;
using pointer_type = void*;
using CV = char* (int);
```
]

Finally the motivating (and name-giving) example:
```
template<typename CharType, std::size_t AllocSize>
class basic_fstring {
    …
};
template<std::size_t N> using fstring = basic_fstring<char, N>;
template<std::size_t N> using wfstring = basic_fstring<wchar_t, N>;
```

</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>
